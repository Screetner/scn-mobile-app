import 'dart:convert';
import 'dart:io';

/// Implementations of this interface are used to lookup a
/// [fingerprint] with the corresponding [directory].
///
/// This functionality is used to allow resuming uploads.
abstract class DirectoryUploadStoreI {
  /// Store a new [fingerprint] and its upload uri map [uploadMap].
  Future<void> set(String fingerprint, Map<String, Uri> uploadMap);

  /// Retrieve an upload uri map for a [fingerprint].
  /// If no matching entry is found this method will return empty map.
  Future<Map<String, Uri>> get(String fingerprint);

  /// Remove an entry from the store using an upload's [fingerprint].
  Future<void> remove(String fingerprint);
}

/// This class is used to lookup a [fingerprint] with the
/// corresponding [file] entries in a [Map].
///
/// This functionality is used to allow resuming uploads.
///
/// This store **will not** keep the values after your application crashes or
/// restarts.
class DirectoryUploadMemoryStore implements DirectoryUploadStoreI {
  Map<String, Map<String, Uri>> store = {};

  @override
  Future<void> set(String fingerprint, Map<String, Uri> uploadMap) async {
    store[fingerprint] = uploadMap;
  }

  @override
  Future<Map<String, Uri>> get(String fingerprint) async {
    return store[fingerprint] ?? <String, Uri>{};
  }

  @override
  Future<void> remove(String fingerprint) async {
    store.remove(fingerprint);
  }
}

/// [DirectoryUploadFileStore] is used for storing upload progress locally on the device.
/// It is used by [DirectoryUploadClient] to resume uploads at correct %.
class DirectoryUploadFileStore implements DirectoryUploadStoreI {
  /// It must receive the directory to store the upload.
  DirectoryUploadFileStore(this.directory);

  /// The directory where the upload  is stored.
  final Directory directory;

  /// Store a new [fingerprint] and its upload [uploadMap]. The [fingerprint] is
  /// generated by [TusClient] and is used to identify the upload. Basically
  /// it's a made of the file location + file name.
  @override
  Future<void> set(String fingerprint, Map<String, Uri> uploadMap) async {
    final file = await _getFile(fingerprint);
    await file.writeAsString(await _encodeMap(uploadMap));
  }

  /// Retrieve an upload's Uri for a [fingerprint].
  /// If no matching entry is found this method will return `null`.
  @override
  Future<Map<String, Uri>> get(String fingerprint) async {
    final file = await _getFile(fingerprint);
    if (file.existsSync()) {
      return _decodeMap(await file.readAsString());
    }
    return <String, Uri>{};
  }

  /// Remove an entry from the store using an upload's [fingerprint].
  @override
  Future<void> remove(String fingerprint) async {
    final file = await _getFile(fingerprint);

    if (file.existsSync()) {
      file.deleteSync();
    }

    if (directory.existsSync()) {
      directory.deleteSync(recursive: true);
    }
  }

  Future<File> _getFile(String fingerprint) async {
    final filePath = '${directory.absolute.path}/$fingerprint';
    return File(filePath);
  }

  Future<String> _encodeMap(Map<String, Uri> map) async {
    final jsonMap = map.map((key, value) => MapEntry(key, value.toString()));
    return jsonEncode(jsonMap);
  }

  Future<Map<String, Uri>> _decodeMap(String rawString) async {
    final jsonMap = jsonDecode(rawString) as Map<String, dynamic>;
    return jsonMap.map((key, value) => MapEntry(key, Uri.parse(value)));
  }
}
